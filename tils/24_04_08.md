## 비동기 JavaScript: 콜백에서 RxJS까지

### 동기 vs 비동기 컴퓨팅

- **동기 실행**은 한 코드 블록이 끝나면 다음 블록이 시작하게 됨. JavaScript에서 긴 실행 작업을 동기적으로 처리하는 건 좋지 않음. 이는 단일 스레드 특성 때문임.
- **비동기 함수**를 쓰면 애플리케이션이 계속 응답할 수 있게 해줌. 이는 사용자 경험을 개선함.

### 블로킹 코드의 문제

- 동기 실행 시, 한 작업이 끝난 후에야 다음 작업이 시작됨. JavaScript의 단일 스레드 특성 때문에, 긴 실행 작업은 동기적으로 처리해선 안 됨.

### 시간과 공간의 이해

- 동기 프로그램에서는 명령어 순서대로 변수들의 상태를 쉽게 알 수 있어, 작성, 유지보수, 디버깅이 쉬움. 그러나 비동기 작업은 예측할 수 없는 시간에 완료될 수 있어, 제대로 다루려면 적절한 방법이 필요함.

### 콜백의 한계

- 콜백 함수는 오랫동안 JavaScript 개발에 쓰였지만, 비동기 코드를 처리할 때 많은 제한이 있음.

### 이벤트 에미터

- 이벤트 에미터는 비동기 이벤트 기반 아키텍처에서 사용되는 메커니즘임. 그러나, 다중 리소스로부터 데이터를 처리할 때 문제가 생길 수 있음.

### 프로미스를 통한 개선

- 프로미스는 ES6에서 소개된 비동기 계산을 수행하는 새로운 기능으로, 나중에 완료될 것으로 예상되는 모든 비동기 계산에 대해 구독할 수 있게 해줌.

### 다른 패러다임의 필요성

- JavaScript의 많은 비동기 라이브러리들은 한계가 있음. 올바른 패러다임 선택이 중요. RxJS는 함수형 프로그래밍과 반응형 프로그래밍의 원칙을 결합하여 이러한 문제를 해결함.

### JavaScript를 위한 반응형 확장

- RxJS는 콜백이나 프로미스 기반 라이브러리를 대체하는 우아한 솔루션을 제공함. 모든 이벤트 소스를 동일한 방식으로 처리할 수 있음.
